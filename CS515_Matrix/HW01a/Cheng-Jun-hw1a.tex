\documentclass{article}

% Packages required to support encoding
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% Packages required by code


% Packages always used
\usepackage{hyperref}
\usepackage{xspace}
\usepackage[usenames,dvipsnames]{color}
\hypersetup{colorlinks=true,urlcolor=blue}

\input{homework.tex}


\begin{document} 
\hypertarget{homework_1a_1}{}\section*{{Homework 1a}}\label{homework_1a_1}

Please answer the following questions in complete sentences in a clearly prepared manuscript and submit the solution by the due date on Blackboard (around Friday, September 4th, 2015.)

Remember that this is a graduate class. There may be elements of the problem statements that require you to fill in appropriate assumptions. You are also responsible for determining what evidence to include. An answer alone is rarely sufficient, but neither is an overly verbose description required. Use your judgement to focus your discussion on the most interesting pieces. The answer to ``{}should I include `{}something'{} in my solution?''{} will almost always be: Yes, if you think it helps support your answer.

\hypertarget{problem_0_homework_checklist_2}{}\subsection*{{Problem 0: Homework checklist}}\label{problem_0_homework_checklist_2}

\begin{itemize}%
\item Please identify anyone, whether or not they are in the class, with whom you discussed your homework. This problem is worth 1 point, but on a multiplicative scale.


\item Make sure you have included your source-code and prepared your solution according to the most recent Piazza note on homework submissions.



\end{itemize}
\hypertarget{problem_1_operations_3}{}\subsection*{{Problem 1: Operations}}\label{problem_1_operations_3}

Compute the following by hand or using Matlab. The vector $\ve = \bmat{1 & \ldots & 1}^T$ (i.e. the all ones vector).

\begin{enumerate}%
\item $\bmat{ 1 & 1 & 2 \\ 3 & 5 & 8 \\ 13 & 21 & 34 } \bmat{ 1 & -2 & 3 \\ -4 & 5 & -6 \\ 7 & -8 & 9} =\bmat{11 & -13 & 15 \\ 39 & -45 & 51 \\ 167 & -193 & 219}$



\item $\vx =$ {\colorbox[rgb]{1.00,0.93,1.00}{\tt ones\char40\char49\char48\char48\char48\char44\char49\char41}} $\vy =$ {\colorbox[rgb]{1.00,0.93,1.00}{\tt \char91\char49\char58\char49\char48\char48\char48\char93\char39}} $\vx^T \vy =$ 500500.0

(Optional extra question --{} worth no points --{} who is always credited with discovering a very efficient way to compute this as a child?)

\emph{Numpy users} $\vx =$ {\colorbox[rgb]{1.00,0.93,1.00}{\tt ones\char40\char40\char49\char48\char48\char48\char44\char49\char41\char41}} $\vy =$ {\colorbox[rgb]{1.00,0.93,1.00}{\tt arange\char40\char49\char46\char44\char49\char48\char48\char49\char46\char41\char91\char58\char44\char32newaxis\char93\char39}}


\item $\vx = \bmat{ 2 & 4 & -1}^T$. \newline  $\ve \vx^T =$5 \newline  $\vx \ve^T =\bmat{2 & 2 & 2 \\ 4 & 4  &4 \\ -1 & -1 & -1 } $


\item $\vx = \bmat{1 & -18 & 3}^T$. \newline  $\ve_1 \vx^T =$-14 \newline  $\vx \ve_3^T =\bmat{1& 1 & 1\\ -18 & -18& -18 \\ 3 & 3 & 3} $



\end{enumerate}
\hypertarget{problem_2_a_proof_4}{}\subsection*{{Problem 2: A proof}}\label{problem_2_a_proof_4}

Let $\mA$ and $\mC$ be invertible matrices. We'{}ll prove that the inverse of $\bmat{ \mA & \mB \\ 0 & \mC }$ is easy to determine!

\begin{enumerate}%
\item Show that the inverse of

\begin{displaymath}
\bmat{ 1 & a \\ 0 & 1 }
\end{displaymath}
is

\begin{displaymath}
\bmat{ 1 & -a \\ 0 & 1 }.
\end{displaymath}

Prove: \newline
\begin{displaymath}
\bmat{ 1 & a \\ 0 & 1 }
\bmat{ 1 & -a \\ 0 & 1 } =\bmat{ 1 & 0 \\ 0 & 1 } .
\end{displaymath}



\item Now, show that the inverse of

\begin{displaymath}
\bmat{ \mI & \mA \\ 0 & \mI }
\end{displaymath}
is

\begin{displaymath}
\bmat{ \mI  & -\mA  \\ 0 & \mI  }.
\end{displaymath}
Prove: \newline
\begin{displaymath}
\bmat{ \mI & \mA \\ 0 & \mI }
\bmat{ \mI  & -\mA  \\ 0 & \mI  } = \bmat{ \mI  & 0  \\ 0 & \mI  }.
\end{displaymath}


\item Recall that for general $\mA$ and $\mB$, not those in the problem!, $(\mA \mB)^{-1} = \mB^{-1} \mA^{-1}$. Use this fact, and the result of problem 2.2 to determine the inverse to $\bmat{ \mA & \mB \\ 0 & \mC }$ when $\mA$ and $\mC$ are invertible. Alternatively, give the inverse of $\bmat{ \mA & \mB \\ 0 & \mC }$. Hint: think about diagonal matrices!



\end{enumerate}
\hypertarget{problem_3_a_statistical_test_5}{}\subsection*{{Problem 3: A statistical test}}\label{problem_3_a_statistical_test_5}

\textbf{This problem will be more difficult if you haven'{}t used Matlab or Scipy/Numpy before, so get started early! It'{}s designed to give you some simple experience.}

One way of viewing a rank-1 matrix is as any matrix that can be written as a single outer-product, that is, $\mA = \vx \vy^T$ for some $\vx$ and some $\vy$.

In this problem, we'{}ll look at the expected value of the \emph{random matrix} $\mB$ where $\mB$ is a random rank-1 matrix following a simple probability distribution.

\begin{enumerate}%
\item The first question is just to get you to document your initial impressions and is not worth any points. Suppose that $\vx$ and $\vy$ are length $n$ vectors with elements drawn from a standard normal distribution. Let $\mB = \vx \vy^T$. Then, let $\mC = E[\mB] = E[\vx \vy^T]$, where $E$ is the expected-value operator. What do you think the rank of $\mC$ is (guessing is fine!)? (Remember this isn'{}t worth any points, so don'{}t think about it too long or get hung up on small details.)

Solution:  The rank of $\mC$ should be zero. Because for a standard normal distribution $\vx$ the expectation value  $E[x^2] = \sigma^2 $ 

\item Now, let'{}s check your guess! We can approximate $\mC$ using what'{}s called a Monte-Carlo approximation. Suppose that $\mB_i = \vx_i \vy_i^T$ is a single matrix generated where $\vx_i$ and $\vy_i$ are \emph{instances} of length-$n$ vectors with elements drawn from a random normal. Then the Monte Carlo approximation to $\mC$ is given by:

\begin{displaymath}
\mC \approx \sum_{i=1}^N \frac{1}{N} \mB_i = \sum_{i=1}^N  \frac{1}{N} \vx_i \vy_i^T.
\end{displaymath}
We can generate $\vx_i$ and $\vy_i$ in Matlab/Numpy/Julia via

Matlab

\begin{verbatim} x = randn(n,1); 
 y = randn(n,1);\end{verbatim}
Numpy/Python

\begin{verbatim} import numpy
 x = numpy.random.randn(n,1) # Numpy
 y = numpy.random.randn(n,1)\end{verbatim}
Julia

\begin{verbatim} x = randn(n); # Julia
 y = randn(n); \end{verbatim}
Using your language of choice, evaluate $\mC$ where $N = 10000$ and $n=6$ and report the rank.


\item Did you find the rank surprising given your initial guess? If so, comment on which you think is correct, your code (2) or your guess (1). (Hint: your code should be correct, but maybe you don'{}t trust an \emph{approximation}?)



\end{enumerate}
\hypertarget{problem_4_image_downsampling_6}{}\subsection*{{Problem 4: Image downsampling}}\label{problem_4_image_downsampling_6}

\textbf{This problem will be more difficult if you haven'{}t used Matlab or Scipy/Numpy before, so get started early! It'{}s designed to teach you about writing {\colorbox[rgb]{1.00,0.93,1.00}{\tt for}} loops to construct a matrix operation for a particular task.}

Consider the following problem. We have a $32 \times 32$ pixel image. Each pixel is a real-valued number between $0$ and $1$. However, I want to show this on a coffee maker screen and I only have a $16 \times 16$ pixel area to show the image. In order to reduce the size of the image, I want to average groups of 4 pixels. In this problem, we'{}ll create a matrix-based program to do this

Let'{}s work through a smaller example first. For the $4 \times 4$ image, represented here by a matrix-like array:

\begin{displaymath}
\bmat{ x_{1} & x_2 & x_3 & x_4 \\          x_5 & x_6 & x_7 & x_8 \\
          x_9 & x_{10} & x_{11} & x_{12} \\
          x_{13} & x_{14} & x_{15} & x_{16} }
\end{displaymath}
I want to compute

\begin{displaymath}
\bmat{ (x_1 + x_2 + x_5 + x_6)/4 & (x_3 + x_4 + x_7 + x_8)/4 \\   (x_9 + x_{10} + x_{13} + x_{14})/4 & (x_{11} + x_{12} + x_{15} + x_{16})/4 }.
\end{displaymath}
We will solve this problem using a matrix-vector product.

\begin{enumerate}%
\item Suppose I call:

\begin{displaymath}
\begin{matrix}     y_1 = (x_1 + x_2 + x_5 + x_6)/4 & y_2 = (x_3 + x_4 + x_7 + x_8)/4 \\
    y_3 = (x_9 + x_{10} + x_{13} + x_{14})/4 & y_4 = (x_{11} + x_{12} + x_{15} + x_{16})/4. \end{matrix}
\end{displaymath}
Further, suppose we consider the vectors $\vy \in \RR^{4}$ and $\vx \in \RR^{16}$ to be the new image and old image, respectively. Write down the matrix $\mA$ such that $\vy = \mA \vx$.

\textbf{In the remainder of the problem, we'{}ll work through how to do this for a particular image in with additional guidance for using (i) Matlab or (ii) Scipy and Numpy.}

\textbf{You may use any software you like for this problem, although you must treat it as a matrix problem.}


\item Download \url{http://www.cs.purdue.edu/homes/dgleich/cs515-2014/homeworks/smallicon.mat} and type

\begin{verbatim} load smallicon.mat \end{verbatim}
in Matlab. You should get a $32 \times 32$ matrix $\mX$. What is the sum of diagonal elements of $\mX$? (If you wish to use another programming language, feel free, but make sure you can do the same things in it. I'{}ve provided \url{http://www.cs.purdue.edu/homes/dgleich/cs515-2014/homeworks/smallicon.txt} as a text file for use in other languages.)

\emph{Scipy and Numpy} Use {\colorbox[rgb]{1.00,0.93,1.00}{\tt scipy\char46io}} to read Matlab mat files

\begin{verbatim} from scipy.io import loadmat
 filedata = loadmat('smallicon.mat')
 X = filedata['X']\end{verbatim}
\emph{Julia} Ask on Piazza for Julia help!


\item Matlab has a command for viewing a matrix as an image. Run the following commands:

\begin{verbatim} imagesc(X)\end{verbatim}
The result looks really weird, right? That'{}s because Matlab is making up a color for each pixel. We can tell it to use a greyscale colormap by executing:

\begin{verbatim} colormap(gray)\end{verbatim}
Save the resulting Matlab figure as an image to include in your homework. (You'{}ll need to do this for future homeworks, so make sure you know how to do it on this one!)

\emph{Scipy and Numpy} use {\colorbox[rgb]{1.00,0.93,1.00}{\tt imshow\char40X\char44\char32extent\char61\char91\char48\char44\char32\char49\char44\char32\char48\char44\char32\char49\char93\char41}} and {\colorbox[rgb]{1.00,0.93,1.00}{\tt set\char95cmap\char40\char39gray\char39\char41}} instead


\item In what follows, we'{}ll talk about two different types of indices. The image index of a pixel is a pair $(i,j)$ that identifies a row and column for the pixel in the image. The vector index of a pixel is the index of that pixel in a linear ordering of the image elements. For instance, in the sample from part 1, pixel (3,2) has linear index $10$. Also, pixel (1,4) has index $4$. Matlab can help us built a map between pixel indices and linear or vector indices:

\begin{verbatim} N = reshape(1:(4*4), 4, 4)';\end{verbatim}
This creates the pixel index to linear index for the problem above because

\begin{verbatim} N(1,4) 
 N(3,2)\end{verbatim}
return the appropriate entry.

In your own words, explain what the {\colorbox[rgb]{1.00,0.93,1.00}{\tt reshape}} operation does. What happens if you omit the final transpose above and try:

\begin{verbatim} N = reshape(1:(4*4), 4, 4);\end{verbatim}
instead?

\emph{Scipy and Numpy} Beware that these index from 0 instead of 1, so you'{}ll need to adjust the indices.

\emph{Julia} Basically the same as Matlab.


\item Now we need to construct the matrix $\mA$ in order to reduce the size of $\mX$. Suppose we call the output vector $\vy$ and the output image $\mY$. I'{}m giving you the following template, that I hope you can fill in. Feel free to construct $\mA$ any way you choose, but the following should provide some guidance.

\begin{verbatim} NX = <fill in>; % the map between pixel indices and linear indices for X
 NY = <fill in>; % the map between pixel indices and linear indices for Y
 for i=1:32
     for j=1:32    
         xi = <fill in>; % the index of the pixel i,j in the vector x
         yij = <fill in>; % the resulting location of pixel in the matrix Y
         yi = <fill in>; % the index of the linear pixel in the vector y
         
         A(yi,xi) = 1/4; % place the entry of the matrix
     end
  end\end{verbatim}

\item In order to use the matrix $\mA$ we created, we need to convert the matrix $\mX$ into a vector! The reshape operation helps here:

\begin{verbatim} x = reshape(X',32*32,1);\end{verbatim}
We can now rescale the image $\mX$ by multiplying by $\mA$ and reorganizing back into a matrix $\mY$.

\begin{verbatim} y = A*x;
 Y = reshape(y,16,16)';\end{verbatim}
Show the image of $\mY$. Does that look correct?

\emph{Scipy and Numpy} Use {\colorbox[rgb]{1.00,0.93,1.00}{\tt X\char46T}} for the transpose of {\colorbox[rgb]{1.00,0.93,1.00}{\tt X}}, also make sure to use {\colorbox[rgb]{1.00,0.93,1.00}{\tt dot\char40A\char44x\char41}} for the matrix multiply.

\emph{Julia} Like Matlab


\item The Matlab way to solve this problem is to use the built in routine {\colorbox[rgb]{1.00,0.93,1.00}{\tt interp\char50}}. In this case, you can call

\begin{verbatim} Ym = interp2(X,-1)\end{verbatim}
to accomplish the same goal and save the output to a Matlab variable {\colorbox[rgb]{1.00,0.93,1.00}{\tt Ym}}.

Do {\colorbox[rgb]{1.00,0.93,1.00}{\tt Y}} and {\colorbox[rgb]{1.00,0.93,1.00}{\tt Ym}} agree? If not, can you comment on their differences?

\emph{Scipy and Numpy}

\begin{verbatim} from scipy.interpolate import RectBivariateSpline
 Ym = RectBivariateSpline(
         arange(X.shape[0]),arange(X.shape[1]), A
      )(arange(0.,X.shape[0],2.),  arange(0.,X.shape[1],2.))\end{verbatim}
\emph{Julia} Like Matlab


\item Show all of your code for this problem and document it.



\end{enumerate}

\end{document}
